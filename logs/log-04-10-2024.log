{"level":"info","message":"Router started","timestamp":"2024-10-04T07:30:21.374Z"}
{"level":"info","message":"server running --- line 9","timestamp":"2024-10-04T07:30:21.378Z"}
{"level":"info","message":"Router finished...","timestamp":"2024-10-04T07:30:21.389Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:30:21.395Z"}
{"level":"info","message":"Router started","timestamp":"2024-10-04T07:32:46.894Z"}
{"level":"info","message":"server running --- line 9","timestamp":"2024-10-04T07:32:46.897Z"}
{"level":"info","message":"Router finished...","timestamp":"2024-10-04T07:32:46.904Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:32:46.909Z"}
{"level":"info","message":"Router started","timestamp":"2024-10-04T07:33:54.368Z"}
{"level":"info","message":"server running --- line 9","timestamp":"2024-10-04T07:33:54.372Z"}
{"level":"info","message":"Router finished...","timestamp":"2024-10-04T07:33:54.381Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:33:54.386Z"}
{"level":"info","message":"Router started","timestamp":"2024-10-04T07:34:54.078Z"}
{"level":"info","message":"server running --- line 9","timestamp":"2024-10-04T07:34:54.082Z"}
{"level":"info","message":"Router finished...","timestamp":"2024-10-04T07:34:54.092Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:34:54.098Z"}
{"level":"info","message":"Router started","timestamp":"2024-10-04T07:35:20.632Z"}
{"level":"info","message":"server running --- line 9","timestamp":"2024-10-04T07:35:20.644Z"}
{"level":"info","message":"Router finished...","timestamp":"2024-10-04T07:35:20.671Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:35:20.684Z"}
{"level":"info","message":"Router started","timestamp":"2024-10-04T07:35:51.921Z"}
{"level":"info","message":"server running --- line 9","timestamp":"2024-10-04T07:35:51.925Z"}
{"level":"info","message":"Router finished...","timestamp":"2024-10-04T07:35:51.936Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:35:51.942Z"}
{"level":"info","message":"Router started","timestamp":"2024-10-04T07:37:26.139Z"}
{"level":"info","message":"server running --- line 9","timestamp":"2024-10-04T07:37:26.143Z"}
{"level":"info","message":"Router finished...","timestamp":"2024-10-04T07:37:26.153Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:37:26.157Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:37:39.043Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:37:51.708Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:38:52.443Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:39:05.193Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:39:12.713Z"}
{"code":"42P01","file":"parse_relation.c","length":109,"level":"error","line":"1452","message":"Error in userSignUp: relation \"ublisusers\" does not exist","name":"error","position":"13","routine":"parserOpenTable","severity":"ERROR","stack":"error: relation \"ublisusers\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T07:39:12.844Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:39:38.117Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:39:50.001Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:40:05.140Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:40:14.025Z"}
{"code":"42703","file":"parse_target.c","length":130,"level":"error","line":"1071","message":"Error in userSignUp: column \"refstid\" of relation \"ublisusers\" does not exist","name":"error","position":"44","routine":"checkInsertTargets","severity":"ERROR","stack":"error: column \"refstid\" of relation \"ublisusers\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T07:40:14.177Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:40:59.764Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:41:05.867Z"}
{"code":"42703","file":"parse_target.c","length":130,"level":"error","line":"1071","message":"Error in userSignUp: column \"refstid\" of relation \"ublisusers\" does not exist","name":"error","position":"44","routine":"checkInsertTargets","severity":"ERROR","stack":"error: column \"refstid\" of relation \"ublisusers\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T07:41:05.976Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:43:01.534Z"}
{"code":"42703","file":"parse_target.c","length":133,"level":"error","line":"1071","message":"Error in userSignUp: column \"refstemail\" of relation \"ublisusers\" does not exist","name":"error","position":"63","routine":"checkInsertTargets","severity":"ERROR","stack":"error: column \"refstemail\" of relation \"ublisusers\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T07:43:01.786Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:48:57.931Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:49:06.463Z"}
{"code":"42703","file":"parse_target.c","length":136,"level":"error","line":"1071","message":"Error in userSignUp: column \"refsIsActive\" of relation \"ublisusers\" does not exist","name":"error","position":"382","routine":"checkInsertTargets","severity":"ERROR","stack":"error: column \"refsIsActive\" of relation \"ublisusers\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T07:49:06.616Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:49:57.234Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:49:59.664Z"}
{"code":"42703","file":"parse_target.c","length":137,"level":"error","line":"1071","message":"Error in userSignUp: column \"refstIsActive\" of relation \"ublisusers\" does not exist","name":"error","position":"382","routine":"checkInsertTargets","severity":"ERROR","stack":"error: column \"refstIsActive\" of relation \"ublisusers\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T07:49:59.772Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:51:11.866Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:52:48.561Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:53:11.004Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:53:20.351Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:53:22.646Z"}
{"code":"42703","file":"parse_target.c","length":137,"level":"error","line":"1071","message":"Error in userSignUp: column \"refstIsActive\" of relation \"ublisusers\" does not exist","name":"error","position":"382","routine":"checkInsertTargets","severity":"ERROR","stack":"error: column \"refstIsActive\" of relation \"ublisusers\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T07:53:22.800Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:53:35.345Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:53:37.345Z"}
{"code":"42703","file":"parse_target.c","length":137,"level":"error","line":"1071","message":"Error in userSignUp: column \"refSignupDate\" of relation \"ublisusers\" does not exist","name":"error","position":"409","routine":"checkInsertTargets","severity":"ERROR","stack":"error: column \"refSignupDate\" of relation \"ublisusers\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T07:53:37.451Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:54:09.749Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:54:12.358Z"}
{"code":"23502","column":"refUtHistory","detail":"Failing row contains (557b355c-bb87-4fcb-a5f4-c5c7cd315154, testuser@example.com, YourSecurePassword123, $2a$10$hGT8oOWYRKVgix5fE3YSV.6404aC6Gvty0SDKiQ0Vf7kFcZ6ril.m, John, Doe, null, 1990-01-01, 34, null, null, null, 2024-10-04, system, 2024-10-04, system, null, null, active, null, null, null, null, null, null, 2024-10-04, null, null, null, null, active, null).","file":"execMain.c","length":551,"level":"error","line":"2009","message":"Error in userSignUp: null value in column \"refUtHistory\" of relation \"ublisusers\" violates not-null constraint","name":"error","routine":"ExecConstraints","schema":"UBLIS","severity":"ERROR","stack":"error: null value in column \"refUtHistory\" of relation \"ublisusers\" violates not-null constraint\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","table":"ublisusers","timestamp":"2024-10-04T07:54:12.486Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T07:55:16.440Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:55:50.184Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:56:23.673Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:57:01.662Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T07:57:05.790Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T08:01:07.851Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T08:01:31.739Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T08:02:21.637Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T08:30:48.076Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T08:30:57.683Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T08:31:03.659Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T08:31:10.940Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T08:33:44.135Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T08:33:59.873Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T08:34:05.867Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T08:34:09.108Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T08:34:21.094Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:36:21.036Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:36:33.796Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:36:42.969Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:36:49.531Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:36:59.299Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:37:09.153Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:37:14.037Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:37:19.834Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:37:23.899Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:37:44.773Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:37:58.855Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:38:08.903Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:38:16.498Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:38:45.796Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:38:58.935Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:41:53.153Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:42:11.256Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T09:42:16.470Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:47:04.766Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:47:12.742Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:47:50.187Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:48:01.354Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:48:13.596Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:48:20.368Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:48:26.272Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:49:38.974Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:50:04.742Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:50:04.743Z"}
{"level":"error","message":"Error in userLogin: this.resolver.userLoginV2 is not a function","stack":"TypeError: this.resolver.userLoginV2 is not a function\n    at UserController.<anonymous> (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\users\\controller.ts:26:38)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\users\\controller.ts:8:71\n    at new Promise (<anonymous>)\n    at __awaiter (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\users\\controller.ts:4:12)\n    at UserController.userLogin (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\users\\controller.ts:16:21)\n    at exports.Manager.execute (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\toolkit.js:57:29)\n    at Object.internals.handler (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\handler.js:46:48)\n    at exports.execute (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\handler.js:31:36)\n    at Request._lifecycle (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\request.js:370:68)","timestamp":"2024-10-04T09:50:04.748Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:50:21.328Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:50:26.017Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:50:28.038Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:50:28.039Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:50:28.040Z"}
{"code":"42P01","file":"parse_relation.c","length":109,"level":"error","line":"1452","message":"Error in userLogin: relation \"ublisusers\" does not exist","name":"error","position":"15","routine":"parserOpenTable","severity":"ERROR","stack":"error: relation \"ublisusers\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T09:50:28.057Z"}
{"level":"error","message":"Error in userLogin: Database error","success":false,"timestamp":"2024-10-04T09:50:28.058Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:51:09.869Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:51:15.305Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:51:15.306Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:51:15.308Z"}
{"code":"42703","file":"parse_relation.c","hint":"Perhaps you meant to reference the column \"ublisusers.refStCustId\".","length":180,"level":"error","line":"3738","message":"Error in userLogin: column \"refstcustid\" does not exist","name":"error","position":"40","routine":"errorMissingColumn","severity":"ERROR","stack":"error: column \"refstcustid\" does not exist\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\pg-pool\\index.js:45:11\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2024-10-04T09:51:15.325Z"}
{"level":"error","message":"Error in userLogin: Database error","success":false,"timestamp":"2024-10-04T09:51:15.327Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:52:39.302Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:52:41.108Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:52:41.109Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:52:41.110Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:54:54.574Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:54:56.697Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:54:56.698Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:54:56.699Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:55:13.609Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:55:15.607Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:55:15.608Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:55:15.609Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:55:34.767Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:55:40.005Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:55:40.006Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:55:40.007Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:56:06.446Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:56:11.472Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:56:11.472Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:56:11.473Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:56:38.863Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:56:45.704Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:56:45.705Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:56:45.706Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:57:14.391Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:57:14.392Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:57:14.393Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:57:24.540Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:57:24.540Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:57:24.541Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T09:57:29.850Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T09:57:29.851Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T09:57:29.852Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T09:57:55.849Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T10:11:10.206Z"}
{"level":"info","message":"Router - sign up page","timestamp":"2024-10-04T10:11:17.980Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:11:41.873Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:25:16.823Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:25:30.918Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:28:18.718Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:28:34.924Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:36:07.940Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:36:28.572Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:46:36.998Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:46:53.806Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T10:47:00.440Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T10:47:00.441Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T10:47:00.442Z"}
{"level":"info","message":"Router----- line 17","timestamp":"2024-10-04T10:47:10.399Z"}
{"level":"info","message":"GET URL REQ => http://localhost:6200/api/v1/users/login","timestamp":"2024-10-04T10:47:10.400Z"}
{"level":"info","message":"User login API triggered --- ","timestamp":"2024-10-04T10:47:10.401Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:47:43.390Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T10:47:55.449Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:01:08.326Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:01:45.957Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:01:51.428Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:01:56.043Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:02:04.733Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:02:10.230Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:02:24.899Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:02:33.592Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:02:46.116Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:02:57.693Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:03:02.736Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:03:13.827Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:03:22.674Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:03:31.562Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:03:46.625Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:03:52.486Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:03:58.033Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:04:03.305Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:04:15.924Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:04:42.223Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:04:58.804Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:05:05.495Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:05:31.137Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:05:36.406Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:05:45.862Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:05:57.293Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:06:06.618Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:06:18.925Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:06:28.607Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:06:42.653Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:06:52.024Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:07:01.781Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:07:14.503Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:07:20.839Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:07:35.019Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:07:57.245Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:08:02.034Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:08:10.404Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:08:21.558Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:08:36.363Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:08:41.357Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:08:55.440Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:09:24.351Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:09:29.162Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:09:34.147Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:09:38.918Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:10:20.071Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:10:43.327Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:10:48.796Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:10:59.149Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:11:39.438Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:17:52.671Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:18:13.733Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:18:19.717Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:18:26.489Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:18:34.122Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:18:43.417Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:18:53.283Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:19:33.457Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:19:54.532Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:20:10.334Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:20:15.427Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:20:24.687Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:20:33.450Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:20:49.894Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:21:02.289Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:21:09.687Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:21:16.358Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:21:30.082Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:21:34.518Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:21:51.996Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:22:00.347Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:22:15.029Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:22:21.775Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:22:34.255Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:22:49.449Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:22:55.962Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:23:06.864Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:23:12.668Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:23:31.690Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:23:36.528Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:23:43.846Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:24:02.531Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:24:09.995Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:24:37.301Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:24:42.595Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:25:21.648Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:25:32.714Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:25:44.580Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:26:00.736Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:26:19.588Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:26:31.016Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:26:38.030Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:26:54.935Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:27:03.978Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:27:36.940Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:27:44.675Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:27:53.415Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:28:02.955Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:28:22.012Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:28:30.681Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:28:47.356Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:28:54.618Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:29:10.579Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:29:16.605Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:29:26.818Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:29:45.746Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:29:56.347Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:30:03.741Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:30:34.224Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:30:43.417Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:31:06.037Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:31:11.986Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:31:32.424Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:31:39.297Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:36:11.991Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:36:34.335Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:36:40.616Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:37:02.579Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:37:13.387Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:38:08.680Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:38:15.200Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:39:02.050Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:39:32.876Z"}
{"level":"error","message":"Server not running... Invalid routeConfig options (post /api/v1/staff/login) {\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false,\n    \"preflightStatusCode\": 200\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\THIRU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"headers\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"user_id\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          },\n          {\n            \"key\": \"password\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          },\n          {\n            \"key\": \"domain\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"tags\": [\n    \"api\",\n    \"Staff\",\n    \"Login\"\n  ],\n  \"auth\": false,\n  \"descrption\" \u001b[31m[1]\u001b[0m: \"Staff Login Checking\"\n}\n\u001b[31m\n[1] \"descrption\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/staff/login) {\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false,\n    \"preflightStatusCode\": 200\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\THIRU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"headers\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"user_id\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          },\n          {\n            \"key\": \"password\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          },\n          {\n            \"key\": \"domain\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"tags\": [\n    \"api\",\n    \"Staff\",\n    \"Login\"\n  ],\n  \"auth\": false,\n  \"descrption\" \u001b[31m[1]\u001b[0m: \"Staff Login Checking\"\n}\n\u001b[31m\n[1] \"descrption\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\staff\\routes.ts:13:14\n    at new Promise (<anonymous>)\n    at StaffRoutes.<anonymous> (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\staff\\routes.ts:11:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\staff\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2024-10-04T11:41:06.783Z"}
{"level":"error","message":"Server not running... Invalid routeConfig options (post /api/v1/staff/login) {\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false,\n    \"preflightStatusCode\": 200\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\THIRU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"headers\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"user_id\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          },\n          {\n            \"key\": \"password\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          },\n          {\n            \"key\": \"domain\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"tags\": [\n    \"api\",\n    \"Staff\",\n    \"Login\"\n  ],\n  \"auth\": false,\n  \"descrption\" \u001b[31m[1]\u001b[0m: \"Staff Login Checking\"\n}\n\u001b[31m\n[1] \"descrption\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/staff/login) {\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false,\n    \"preflightStatusCode\": 200\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\THIRU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"headers\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"user_id\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          },\n          {\n            \"key\": \"password\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          },\n          {\n            \"key\": \"domain\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"tags\": [\n    \"api\",\n    \"Staff\",\n    \"Login\"\n  ],\n  \"auth\": false,\n  \"descrption\" \u001b[31m[1]\u001b[0m: \"Staff Login Checking\"\n}\n\u001b[31m\n[1] \"descrption\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\staff\\routes.ts:13:14\n    at new Promise (<anonymous>)\n    at StaffRoutes.<anonymous> (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\staff\\routes.ts:11:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\staff\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2024-10-04T11:41:55.062Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:43:07.387Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:43:21.171Z"}
{"level":"error","message":"Server not running... Invalid routeConfig options (post /api/v1/staff/login) {\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false,\n    \"preflightStatusCode\": 200\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\THIRU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {}\n  },\n  \"tags\": [\n    \"api\",\n    \"Staff\",\n    \"Login\"\n  ],\n  \"auth\": false,\n  \"descrption\" \u001b[31m[1]\u001b[0m: \"Staff Login Checking\"\n}\n\u001b[31m\n[1] \"descrption\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/staff/login) {\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"maxAge\": 86400,\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"additionalHeaders\": [],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"additionalExposedHeaders\": [],\n    \"credentials\": false,\n    \"preflightStatusCode\": 200\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\THIRU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {}\n  },\n  \"tags\": [\n    \"api\",\n    \"Staff\",\n    \"Login\"\n  ],\n  \"auth\": false,\n  \"descrption\" \u001b[31m[1]\u001b[0m: \"Staff Login Checking\"\n}\n\u001b[31m\n[1] \"descrption\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\staff\\routes.ts:13:14\n    at new Promise (<anonymous>)\n    at StaffRoutes.<anonymous> (C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\staff\\routes.ts:11:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\THIRU\\Documents\\UblisYogaBackendInitial\\attendanceServices\\src\\api\\staff\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2024-10-04T11:43:38.457Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:47:05.244Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:48:21.532Z"}
{"level":"info","message":"server running --- from server.ts","timestamp":"2024-10-04T11:48:37.788Z"}
